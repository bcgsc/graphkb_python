{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GraphKB Python Adapter User Manual The GraphKB python adapter is a python package to facilitate interacting with the GraphKB API. The GraphKB API is a REST API https://graphkb.bcgsc.ca/api) . The openapi specification is hosted here: https://graphkb-api.bcgsc.ca/api/spec . The client also contains documentation on the background and features of GraphKB This adapter adds functions for common queries as well as for paginating and authenticating Getting Started Install the python adapter with pip pip install graphkb This will require python 3.6 or greater. Next, start incorporating graphkb into your own python project/script. The script below gets version information from graphkb from graphkb import GraphKBConnection gkb_conn = GraphKBConnection () # authenticate the current user gkb_conn . login ( 'myusername' , 'mypassword' ) # get the version information version_metadata = gkb_conn . request ( '/version' ) Querying GraphKB uses the /query endpoint which takes the query arguments in the request body. See the openapi specification for more details on how to build this object. Matching Variants There are 2 main matching functions, one of positional variants and one for category variants. Let's take a look at a couple of examples from graphkb import GraphKBConnection from graphkb.match import match_positional_variant gkb_conn = GraphKBConnection () gkb_conn . login ( 'myusername' , 'mypassword' ) variant_matches = match_positional_variant ( gkb_conn , 'KRAS:p.G12D' ) This will give you a list of variants from GraphKB that are considered to match the input. We can then use this list of variants to fetch related annotations from graphkb.util import convert_to_rid_list annotations = gkb_conn . query ({ 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' } }) This will fetch a list of statements where any of the matched variants are conditions for the statement","title":"Home"},{"location":"#graphkb-python-adapter-user-manual","text":"The GraphKB python adapter is a python package to facilitate interacting with the GraphKB API. The GraphKB API is a REST API https://graphkb.bcgsc.ca/api) . The openapi specification is hosted here: https://graphkb-api.bcgsc.ca/api/spec . The client also contains documentation on the background and features of GraphKB This adapter adds functions for common queries as well as for paginating and authenticating","title":"GraphKB Python Adapter User Manual"},{"location":"#getting-started","text":"Install the python adapter with pip pip install graphkb This will require python 3.6 or greater. Next, start incorporating graphkb into your own python project/script. The script below gets version information from graphkb from graphkb import GraphKBConnection gkb_conn = GraphKBConnection () # authenticate the current user gkb_conn . login ( 'myusername' , 'mypassword' ) # get the version information version_metadata = gkb_conn . request ( '/version' ) Querying GraphKB uses the /query endpoint which takes the query arguments in the request body. See the openapi specification for more details on how to build this object.","title":"Getting Started"},{"location":"#matching-variants","text":"There are 2 main matching functions, one of positional variants and one for category variants. Let's take a look at a couple of examples from graphkb import GraphKBConnection from graphkb.match import match_positional_variant gkb_conn = GraphKBConnection () gkb_conn . login ( 'myusername' , 'mypassword' ) variant_matches = match_positional_variant ( gkb_conn , 'KRAS:p.G12D' ) This will give you a list of variants from GraphKB that are considered to match the input. We can then use this list of variants to fetch related annotations from graphkb.util import convert_to_rid_list annotations = gkb_conn . query ({ 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' } }) This will fetch a list of statements where any of the matched variants are conditions for the statement","title":"Matching Variants"},{"location":"tutorial/","text":"Tutorial This tutorial will cover how to get started using GraphKB to annotate your variants. Install Install graphkb as a dependency of your python script (It is recommended to use a virtual environment) pip install graphkb Connecting to the API The first thing to do is setting up the connection to the API from graphkb import GraphKBConnection graphkb_conn = GraphKBConnection () Next, use this to login graphkb_conn . login ( username , password ) This will store the credentials passed on the connection object and re-login as required. Variant Matches For this example we are going to try matching a protein change ( p.G12D ) on the gene ( KRAS ). from graphkb.match import match_positional_variant variant_name = 'KRAS:p.G12D' variant_matches = match_positional_variant ( graphkb_conn , variant_name ) for match in variant_matches : print ( variant_name , 'will match' , match [ 'displayName' ]) From this step you should see something like this (actual content will vary depending on the instance of the GraphKB API/DB you are using) KRAS:p.G12D will match KRAS:p.G12 KRAS:p.G12D will match KRAS:p.G12X KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS:p.(G12_G13)mut KRAS:p.G12D will match KRAS:p.?12mut KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match chr12:g.25398284C>T KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS mutation As you can see above the match function has pulled similar/equivalent variant representations which we will then use to match statements. Next, use these variant matches to find the related statements Statement Annotations from graphkb.constants import BASE_RETURN_PROPERTIES , GENERIC_RETURN_PROPERTIES from graphkb.util import convert_to_rid_list # return properties should be customized to the users needs return_props = ( BASE_RETURN_PROPERTIES + [ 'sourceId' , 'source.name' , 'source.displayName' ] + [ f 'conditions. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'subject. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidence. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'relevance. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidenceLevel. { p } ' for p in GENERIC_RETURN_PROPERTIES ] ) statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, 'returnProperties' : return_props , } ) for statement in statements [: 5 ]: print ( statement [ 'relevance' ][ 'displayName' ], statement [ 'subject' ][ 'displayName' ], statement [ 'source' ][ 'displayName' ] if statement [ 'source' ] else '' , ) This should output lines similar to the following resistance gefitinib [C1855] CIViC likely pathogenic lung cancer [DOID:1324] DoCM Categorizing Statements Something we often want to know is if a statement is therapeutic, or prognostic, etc. The naive approach is to base this on a list of known terms or a regex pattern. In GraphKB we can leverage the ontology structure instead. In this example we will look for all terms that would indicate a therapeutically relevent statement. To do this we pick our 'base' terms. These are the terms we consider to be the highest level of the ontology tree, the most general term for that category. from graphkb.vocab import get_term_tree BASE_THERAPEUTIC_TERMS = 'therapeutic efficacy' therapeutic_terms = get_term_tree ( graphkb_conn , BASE_THERAPEUTIC_TERMS , include_superclasses = False ) print ( f 'Found { len ( therapeutic_terms ) } equivalent terms' ) for term in therapeutic_terms : print ( '-' , term [ 'name' ]) print () This will result in output like Found 13 equivalent terms - therapeutic efficacy - targetable - response - sensitivity - likely sensitivity - no sensitivity - no response - resistance - reduced sensitivity - likely resistance - innate resistance - acquired resistance - no resistance We can filter the statements we have already retrieved, or we can add this to our original query and filter before we retrive from the API statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'AND' : [ { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, { 'relevance' : convert_to_rid_list ( therapeutic_terms ), 'operator' : 'IN' }, ] }, 'returnProperties' : return_props , } ) for statement in statements : print ( statement [ 'relevance' ][ 'displayName' ]) Similar filtering can be done for the other properties and any other base-term classification you would like to use. Use the graph view at https://graphkb.bcgsc.ca to explore record relationships and decide on the categories you would like to use. The full code for this tutorial can be downloaded from the github repo under docs/tutorial.py","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This tutorial will cover how to get started using GraphKB to annotate your variants.","title":"Tutorial"},{"location":"tutorial/#install","text":"Install graphkb as a dependency of your python script (It is recommended to use a virtual environment) pip install graphkb","title":"Install"},{"location":"tutorial/#connecting-to-the-api","text":"The first thing to do is setting up the connection to the API from graphkb import GraphKBConnection graphkb_conn = GraphKBConnection () Next, use this to login graphkb_conn . login ( username , password ) This will store the credentials passed on the connection object and re-login as required.","title":"Connecting to the API"},{"location":"tutorial/#variant-matches","text":"For this example we are going to try matching a protein change ( p.G12D ) on the gene ( KRAS ). from graphkb.match import match_positional_variant variant_name = 'KRAS:p.G12D' variant_matches = match_positional_variant ( graphkb_conn , variant_name ) for match in variant_matches : print ( variant_name , 'will match' , match [ 'displayName' ]) From this step you should see something like this (actual content will vary depending on the instance of the GraphKB API/DB you are using) KRAS:p.G12D will match KRAS:p.G12 KRAS:p.G12D will match KRAS:p.G12X KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS:p.(G12_G13)mut KRAS:p.G12D will match KRAS:p.?12mut KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match chr12:g.25398284C>T KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS mutation As you can see above the match function has pulled similar/equivalent variant representations which we will then use to match statements. Next, use these variant matches to find the related statements","title":"Variant Matches"},{"location":"tutorial/#statement-annotations","text":"from graphkb.constants import BASE_RETURN_PROPERTIES , GENERIC_RETURN_PROPERTIES from graphkb.util import convert_to_rid_list # return properties should be customized to the users needs return_props = ( BASE_RETURN_PROPERTIES + [ 'sourceId' , 'source.name' , 'source.displayName' ] + [ f 'conditions. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'subject. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidence. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'relevance. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidenceLevel. { p } ' for p in GENERIC_RETURN_PROPERTIES ] ) statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, 'returnProperties' : return_props , } ) for statement in statements [: 5 ]: print ( statement [ 'relevance' ][ 'displayName' ], statement [ 'subject' ][ 'displayName' ], statement [ 'source' ][ 'displayName' ] if statement [ 'source' ] else '' , ) This should output lines similar to the following resistance gefitinib [C1855] CIViC likely pathogenic lung cancer [DOID:1324] DoCM","title":"Statement Annotations"},{"location":"tutorial/#categorizing-statements","text":"Something we often want to know is if a statement is therapeutic, or prognostic, etc. The naive approach is to base this on a list of known terms or a regex pattern. In GraphKB we can leverage the ontology structure instead. In this example we will look for all terms that would indicate a therapeutically relevent statement. To do this we pick our 'base' terms. These are the terms we consider to be the highest level of the ontology tree, the most general term for that category. from graphkb.vocab import get_term_tree BASE_THERAPEUTIC_TERMS = 'therapeutic efficacy' therapeutic_terms = get_term_tree ( graphkb_conn , BASE_THERAPEUTIC_TERMS , include_superclasses = False ) print ( f 'Found { len ( therapeutic_terms ) } equivalent terms' ) for term in therapeutic_terms : print ( '-' , term [ 'name' ]) print () This will result in output like Found 13 equivalent terms - therapeutic efficacy - targetable - response - sensitivity - likely sensitivity - no sensitivity - no response - resistance - reduced sensitivity - likely resistance - innate resistance - acquired resistance - no resistance We can filter the statements we have already retrieved, or we can add this to our original query and filter before we retrive from the API statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'AND' : [ { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, { 'relevance' : convert_to_rid_list ( therapeutic_terms ), 'operator' : 'IN' }, ] }, 'returnProperties' : return_props , } ) for statement in statements : print ( statement [ 'relevance' ][ 'displayName' ]) Similar filtering can be done for the other properties and any other base-term classification you would like to use. Use the graph view at https://graphkb.bcgsc.ca to explore record relationships and decide on the categories you would like to use. The full code for this tutorial can be downloaded from the github repo under docs/tutorial.py","title":"Categorizing Statements"},{"location":"reference/graphkb/__init__/","text":"graphkb DEFAULT_URL DEFAULT_URL = 'https://graphkb-api.bcgsc.ca/api' DEFAULT_LIMIT DEFAULT_LIMIT = 1000 QUERY_CACHE QUERY_CACHE : Dict [ Any , Any ] = {} class GraphKBConnection GraphKBConnection.request() Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict GraphKBConnection.post() Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict GraphKBConnection.set_cache_data() Explicitly add a query to the cache def set_cache_data ( self , request_body : Dict , result : List [ Record ]) -> None : Args request_body ( Dict ) result (List[ Record ]) GraphKBConnection.query() Query GraphKB def query ( self , request_body : Dict = {}, paginate : bool = True , ignore_cache : bool = True , force_refresh : bool = False , limit : int = DEFAULT_LIMIT , ) -> List [ Record ]: Args request_body ( Dict ) paginate ( bool ) ignore_cache ( bool ) force_refresh ( bool ) limit ( int ) Returns List[ Record ] join_url() Join parts of a URL into a full URL def join_url ( base_url : str , * parts ) -> str : Args base_url ( str ) Returns str millis_interval() start and end are datetime instances def millis_interval ( start : datetime , end : datetime ) -> int : Args start ( datetime ) end ( datetime ) Returns int cache_key() create a cache key for a query request to GraphKB def cache_key ( request_body ): Args request_body","title":"graphkb"},{"location":"reference/graphkb/__init__/#graphkb","text":"","title":"graphkb"},{"location":"reference/graphkb/__init__/#default_url","text":"DEFAULT_URL = 'https://graphkb-api.bcgsc.ca/api'","title":"DEFAULT_URL"},{"location":"reference/graphkb/__init__/#default_limit","text":"DEFAULT_LIMIT = 1000","title":"DEFAULT_LIMIT"},{"location":"reference/graphkb/__init__/#query_cache","text":"QUERY_CACHE : Dict [ Any , Any ] = {}","title":"QUERY_CACHE"},{"location":"reference/graphkb/__init__/#class-graphkbconnection","text":"","title":"class GraphKBConnection"},{"location":"reference/graphkb/__init__/#graphkbconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"GraphKBConnection.request()"},{"location":"reference/graphkb/__init__/#graphkbconnectionpost","text":"Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict","title":"GraphKBConnection.post()"},{"location":"reference/graphkb/__init__/#graphkbconnectionset_cache_data","text":"Explicitly add a query to the cache def set_cache_data ( self , request_body : Dict , result : List [ Record ]) -> None : Args request_body ( Dict ) result (List[ Record ])","title":"GraphKBConnection.set_cache_data()"},{"location":"reference/graphkb/__init__/#graphkbconnectionquery","text":"Query GraphKB def query ( self , request_body : Dict = {}, paginate : bool = True , ignore_cache : bool = True , force_refresh : bool = False , limit : int = DEFAULT_LIMIT , ) -> List [ Record ]: Args request_body ( Dict ) paginate ( bool ) ignore_cache ( bool ) force_refresh ( bool ) limit ( int ) Returns List[ Record ]","title":"GraphKBConnection.query()"},{"location":"reference/graphkb/__init__/#join_url","text":"Join parts of a URL into a full URL def join_url ( base_url : str , * parts ) -> str : Args base_url ( str ) Returns str","title":"join_url()"},{"location":"reference/graphkb/__init__/#millis_interval","text":"start and end are datetime instances def millis_interval ( start : datetime , end : datetime ) -> int : Args start ( datetime ) end ( datetime ) Returns int","title":"millis_interval()"},{"location":"reference/graphkb/__init__/#cache_key","text":"create a cache key for a query request to GraphKB def cache_key ( request_body ): Args request_body","title":"cache_key()"},{"location":"reference/graphkb/genes/","text":"graphkb.genes Methods for retrieving gene annotation lists from GraphKB ONCOKB_SOURCE_NAME ONCOKB_SOURCE_NAME = 'oncokb' ONCOGENE ONCOGENE = 'oncogenic' TUMOUR_SUPPRESSIVE TUMOUR_SUPPRESSIVE = 'tumour suppressive' FUSION_NAMES FUSION_NAMES = [ 'structural variant' , 'fusion' ] GENE_RETURN_PROPERTIES GENE_RETURN_PROPERTIES = [ 'name' , '@rid' , '@class' , 'sourceId' , 'sourceIdVersion' , 'source.name' , 'source.@rid' , 'displayName' , 'biotype' , 'deprecated' , ] get_oncokb_oncogenes() Gets the list of oncogenes stored in GraphKB derived from OncoKB def get_oncokb_oncogenes ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records get_oncokb_tumour_supressors() Gets the list of tumour supressor genes stored in GraphKB derived from OncoKB def get_oncokb_tumour_supressors ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records get_genes_from_variant_types() Retrieve a list of Genes which are found in variants on the given types def get_genes_from_variant_types ( conn : GraphKBConnection , types : List [ str ], source_record_ids : List [ str ] = [] ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object types ( List[str] ): list of names of variant types source_record_ids ( List[str] ): list of sources ids to filter genes by Returns List[ Ontology ]: gene (Feature) records","title":"graphkb.genes"},{"location":"reference/graphkb/genes/#graphkbgenes","text":"Methods for retrieving gene annotation lists from GraphKB","title":"graphkb.genes"},{"location":"reference/graphkb/genes/#oncokb_source_name","text":"ONCOKB_SOURCE_NAME = 'oncokb'","title":"ONCOKB_SOURCE_NAME"},{"location":"reference/graphkb/genes/#oncogene","text":"ONCOGENE = 'oncogenic'","title":"ONCOGENE"},{"location":"reference/graphkb/genes/#tumour_suppressive","text":"TUMOUR_SUPPRESSIVE = 'tumour suppressive'","title":"TUMOUR_SUPPRESSIVE"},{"location":"reference/graphkb/genes/#fusion_names","text":"FUSION_NAMES = [ 'structural variant' , 'fusion' ]","title":"FUSION_NAMES"},{"location":"reference/graphkb/genes/#gene_return_properties","text":"GENE_RETURN_PROPERTIES = [ 'name' , '@rid' , '@class' , 'sourceId' , 'sourceIdVersion' , 'source.name' , 'source.@rid' , 'displayName' , 'biotype' , 'deprecated' , ]","title":"GENE_RETURN_PROPERTIES"},{"location":"reference/graphkb/genes/#get_oncokb_oncogenes","text":"Gets the list of oncogenes stored in GraphKB derived from OncoKB def get_oncokb_oncogenes ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records","title":"get_oncokb_oncogenes()"},{"location":"reference/graphkb/genes/#get_oncokb_tumour_supressors","text":"Gets the list of tumour supressor genes stored in GraphKB derived from OncoKB def get_oncokb_tumour_supressors ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records","title":"get_oncokb_tumour_supressors()"},{"location":"reference/graphkb/genes/#get_genes_from_variant_types","text":"Retrieve a list of Genes which are found in variants on the given types def get_genes_from_variant_types ( conn : GraphKBConnection , types : List [ str ], source_record_ids : List [ str ] = [] ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object types ( List[str] ): list of names of variant types source_record_ids ( List[str] ): list of sources ids to filter genes by Returns List[ Ontology ]: gene (Feature) records","title":"get_genes_from_variant_types()"},{"location":"reference/graphkb/match/","text":"graphkb.match Functions which return Variants from GraphKB which match some input variant definition INPUT_COPY_CATEGORIES INPUT_COPY_CATEGORIES = IterableNamespace ( AMP = 'amplification' , ANY_GAIN = 'copy gain' , ANY_LOSS = 'copy loss' , DEEP = 'deep deletion' , GAIN = 'low level copy gain' , LOSS = 'shallow deletion' , ) INPUT_EXPRESSION_CATEGORIES INPUT_EXPRESSION_CATEGORIES = IterableNamespace ( UP = 'increased expression' , DOWN = 'reduced expression' ) AMBIGUOUS_AA AMBIGUOUS_AA = [ 'x' , '?' , 'X' ] VARIANT_RETURN_PROPERTIES VARIANT_RETURN_PROPERTIES = ( BASE_RETURN_PROPERTIES + [ f 'type. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'reference1. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ f 'reference2. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ 'zygosity' , 'germline' , 'displayName' ] POS_VARIANT_RETURN_PROPERTIES POS_VARIANT_RETURN_PROPERTIES = VARIANT_RETURN_PROPERTIES + [ 'break1Start' , 'break1End' , 'break2Start' , 'break2End' , 'break1Repr' , 'break2Repr' , 'refSeq' , 'untemplatedSeq' , 'untemplatedSeqSize' , 'truncation' , 'assembly' , FEATURES_CACHE FEATURES_CACHE : Set [ str ] = set () cache_missing_features() Create a cache of features that exist to avoid repeatedly querying for missing features def cache_missing_features ( conn : GraphKBConnection ) -> None : Args conn ( GraphKBConnection ) match_category_variant() Returns a list of variants matching the input variant def match_category_variant ( conn : GraphKBConnection , gene_name : str , category : str , root_exclude_term : str = '' , gene_source : str = '' , gene_is_source_id : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) root_exclude_term ( str ) gene_source ( str ): The source database the gene is defined by (ex. ensembl) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises FeatureNotFoundError : The gene could not be found in GraphKB match_copy_variant() Returns a list of variants matching the input variant def match_copy_variant ( conn : GraphKBConnection , gene_name : str , category : str , drop_homozygous : bool = False , ** kwargs ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) drop_homozygous ( bool ): Drop homozygous matches from the result when true Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises ValueError : The input copy category is not recognized positions_overlap() Check if 2 Position records from GraphKB indicate an overlap def positions_overlap ( pos_record : BasicPosition , range_start : BasicPosition , range_end : Optional [ BasicPosition ] = None ) -> bool : Args pos_record ( BasicPosition ): the record to compare range_start ( BasicPosition ): the position record indicating the start of an uncertainty range range_end (Optional[ BasicPosition ]): the position record indicating the end of an uncertainty range Returns bool : True if the positions overlap Raises NotImplementedError : if a cytoband type position is given !!! note null values indicate not-specified or any compare_positional_variants() Compare 2 variant records from GraphKB to determine if they are equivalent def compare_positional_variants ( variant : Union [ PositionalVariant , ParsedVariant ], reference_variant : Union [ PositionalVariant , ParsedVariant ], ) -> bool : Args variant (Union[ PositionalVariant , ParsedVariant ]): the input variant reference_variant (Union[ PositionalVariant , ParsedVariant ]): the reference (matched) variant record Returns bool : True if the records are equivalent match_positional_variant() Given the HGVS+ representation of some positional variant, parse it and match it to annotations in GraphKB def match_positional_variant ( conn : GraphKBConnection , variant_string : str , reference1 : Optional [ str ] = None , reference2 : Optional [ str ] = None , gene_is_source_id : bool = False , gene_source : str = '' , ) -> List [ Variant ]: Args conn ( GraphKBConnection ) variant_string ( str ): the HGVS+ annotation string reference1 ( Optional[str] ): Explicitly specify the first reference link record (gene1) reference2 ( Optional[str] ): Explicitly specify the second reference link record (gene2) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names gene_source ( str ): The source database the gene is defined by (ex. ensembl) Returns List[ Variant ]: A list of matched statement records Raises NotImplementedError : thrown for uncertain position input (ranges) FeatureNotFoundError : One of the genes does not exist in GraphKB ValueError : the gene names were given both in the variant_string and explicitly Examples match_positional_variant ( conn , '(EWSR1,FLI1):fusion(e.1,e.2)' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , 'EWSR1' , 'FLI1' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '#3:4' , '#4:5' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '123' , '456' , gene_is_source_id = True , gene_source = 'entrez gene' ) match_positional_variant ( conn , 'KRAS:p.G12D' ) match_positional_variant ( conn , 'p.G12D' , 'KRAS' )","title":"graphkb.match"},{"location":"reference/graphkb/match/#graphkbmatch","text":"Functions which return Variants from GraphKB which match some input variant definition","title":"graphkb.match"},{"location":"reference/graphkb/match/#input_copy_categories","text":"INPUT_COPY_CATEGORIES = IterableNamespace ( AMP = 'amplification' , ANY_GAIN = 'copy gain' , ANY_LOSS = 'copy loss' , DEEP = 'deep deletion' , GAIN = 'low level copy gain' , LOSS = 'shallow deletion' , )","title":"INPUT_COPY_CATEGORIES"},{"location":"reference/graphkb/match/#input_expression_categories","text":"INPUT_EXPRESSION_CATEGORIES = IterableNamespace ( UP = 'increased expression' , DOWN = 'reduced expression' )","title":"INPUT_EXPRESSION_CATEGORIES"},{"location":"reference/graphkb/match/#ambiguous_aa","text":"AMBIGUOUS_AA = [ 'x' , '?' , 'X' ]","title":"AMBIGUOUS_AA"},{"location":"reference/graphkb/match/#variant_return_properties","text":"VARIANT_RETURN_PROPERTIES = ( BASE_RETURN_PROPERTIES + [ f 'type. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'reference1. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ f 'reference2. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ 'zygosity' , 'germline' , 'displayName' ]","title":"VARIANT_RETURN_PROPERTIES"},{"location":"reference/graphkb/match/#pos_variant_return_properties","text":"POS_VARIANT_RETURN_PROPERTIES = VARIANT_RETURN_PROPERTIES + [ 'break1Start' , 'break1End' , 'break2Start' , 'break2End' , 'break1Repr' , 'break2Repr' , 'refSeq' , 'untemplatedSeq' , 'untemplatedSeqSize' , 'truncation' , 'assembly' ,","title":"POS_VARIANT_RETURN_PROPERTIES"},{"location":"reference/graphkb/match/#features_cache","text":"FEATURES_CACHE : Set [ str ] = set ()","title":"FEATURES_CACHE"},{"location":"reference/graphkb/match/#cache_missing_features","text":"Create a cache of features that exist to avoid repeatedly querying for missing features def cache_missing_features ( conn : GraphKBConnection ) -> None : Args conn ( GraphKBConnection )","title":"cache_missing_features()"},{"location":"reference/graphkb/match/#match_category_variant","text":"Returns a list of variants matching the input variant def match_category_variant ( conn : GraphKBConnection , gene_name : str , category : str , root_exclude_term : str = '' , gene_source : str = '' , gene_is_source_id : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) root_exclude_term ( str ) gene_source ( str ): The source database the gene is defined by (ex. ensembl) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises FeatureNotFoundError : The gene could not be found in GraphKB","title":"match_category_variant()"},{"location":"reference/graphkb/match/#match_copy_variant","text":"Returns a list of variants matching the input variant def match_copy_variant ( conn : GraphKBConnection , gene_name : str , category : str , drop_homozygous : bool = False , ** kwargs ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) drop_homozygous ( bool ): Drop homozygous matches from the result when true Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises ValueError : The input copy category is not recognized","title":"match_copy_variant()"},{"location":"reference/graphkb/match/#positions_overlap","text":"Check if 2 Position records from GraphKB indicate an overlap def positions_overlap ( pos_record : BasicPosition , range_start : BasicPosition , range_end : Optional [ BasicPosition ] = None ) -> bool : Args pos_record ( BasicPosition ): the record to compare range_start ( BasicPosition ): the position record indicating the start of an uncertainty range range_end (Optional[ BasicPosition ]): the position record indicating the end of an uncertainty range Returns bool : True if the positions overlap Raises NotImplementedError : if a cytoband type position is given !!! note null values indicate not-specified or any","title":"positions_overlap()"},{"location":"reference/graphkb/match/#compare_positional_variants","text":"Compare 2 variant records from GraphKB to determine if they are equivalent def compare_positional_variants ( variant : Union [ PositionalVariant , ParsedVariant ], reference_variant : Union [ PositionalVariant , ParsedVariant ], ) -> bool : Args variant (Union[ PositionalVariant , ParsedVariant ]): the input variant reference_variant (Union[ PositionalVariant , ParsedVariant ]): the reference (matched) variant record Returns bool : True if the records are equivalent","title":"compare_positional_variants()"},{"location":"reference/graphkb/match/#match_positional_variant","text":"Given the HGVS+ representation of some positional variant, parse it and match it to annotations in GraphKB def match_positional_variant ( conn : GraphKBConnection , variant_string : str , reference1 : Optional [ str ] = None , reference2 : Optional [ str ] = None , gene_is_source_id : bool = False , gene_source : str = '' , ) -> List [ Variant ]: Args conn ( GraphKBConnection ) variant_string ( str ): the HGVS+ annotation string reference1 ( Optional[str] ): Explicitly specify the first reference link record (gene1) reference2 ( Optional[str] ): Explicitly specify the second reference link record (gene2) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names gene_source ( str ): The source database the gene is defined by (ex. ensembl) Returns List[ Variant ]: A list of matched statement records Raises NotImplementedError : thrown for uncertain position input (ranges) FeatureNotFoundError : One of the genes does not exist in GraphKB ValueError : the gene names were given both in the variant_string and explicitly Examples match_positional_variant ( conn , '(EWSR1,FLI1):fusion(e.1,e.2)' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , 'EWSR1' , 'FLI1' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '#3:4' , '#4:5' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '123' , '456' , gene_is_source_id = True , gene_source = 'entrez gene' ) match_positional_variant ( conn , 'KRAS:p.G12D' ) match_positional_variant ( conn , 'p.G12D' , 'KRAS' )","title":"match_positional_variant()"},{"location":"reference/graphkb/statement/","text":"graphkb.statement categorize_relevance() Given the record ID of some relevance term, return the higher level categorization def categorize_relevance ( graphkb_conn : GraphKBConnection , relevance_rid : str , category_base_terms : CategoryBaseTermMapping = RELEVANCE_BASE_TERMS , ) -> str : Args graphkb_conn ( GraphKBConnection ) relevance_rid ( str ) category_base_terms ( CategoryBaseTermMapping ) Returns str","title":"graphkb.statement"},{"location":"reference/graphkb/statement/#graphkbstatement","text":"","title":"graphkb.statement"},{"location":"reference/graphkb/statement/#categorize_relevance","text":"Given the record ID of some relevance term, return the higher level categorization def categorize_relevance ( graphkb_conn : GraphKBConnection , relevance_rid : str , category_base_terms : CategoryBaseTermMapping = RELEVANCE_BASE_TERMS , ) -> str : Args graphkb_conn ( GraphKBConnection ) relevance_rid ( str ) category_base_terms ( CategoryBaseTermMapping ) Returns str","title":"categorize_relevance()"},{"location":"reference/graphkb/types/","text":"graphkb.types Type annotations used for static type checking in this module Record Record : TypedDict = TypedDict ( 'Record' , { '@rid' : str , '@class' : str }) Attributes @rid ( str ) @class ( str ) EmbeddedRecord EmbeddedRecord : TypedDict = TypedDict ( 'EmbeddedRecord' , { '@class' : str }) Attributes @class ( str ) RecordLink RecordLink = Union [ str , Record ] OntologyLink OntologyLink = Union [ str , Ontology ] Position Position = Union [ BasicPosition , CytobandPosition ] CategoryBaseTermMapping CategoryBaseTermMapping = List [ Tuple [ str , List [ str ]]] class Ontology inherits Record Attributes sourceId ( str ) name ( str ) source ( RecordLink ) class BasicPosition inherits EmbeddedRecord Attributes pos ( int ) class CytobandPosition inherits EmbeddedRecord Attributes arm ( str ) majorBand ( str ) minorBand ( str ) class Variant inherits Record Attributes reference1 ( OntologyLink ) reference2 (Optional[ OntologyLink ]) type ( OntologyLink ) zygosity ( str ) germline ( bool ) class PositionalVariant inherits Variant Attributes break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] ) class ParsedVariant inherits TypedDict Attributes reference1 ( str ) reference2 ( Optional[str] ) type ( str ) zygosity ( str ) germline ( bool ) break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] ) class Statement inherits Record Attributes relevance ( OntologyLink ) subject ( OntologyLink ) conditions (List[ OntologyLink ]) evidence (List[ OntologyLink ]) evidenceLevel (List[ OntologyLink ]) source ( RecordLink ) sourceId ( str )","title":"graphkb.types"},{"location":"reference/graphkb/types/#graphkbtypes","text":"Type annotations used for static type checking in this module","title":"graphkb.types"},{"location":"reference/graphkb/types/#record","text":"Record : TypedDict = TypedDict ( 'Record' , { '@rid' : str , '@class' : str }) Attributes @rid ( str ) @class ( str )","title":"Record"},{"location":"reference/graphkb/types/#embeddedrecord","text":"EmbeddedRecord : TypedDict = TypedDict ( 'EmbeddedRecord' , { '@class' : str }) Attributes @class ( str )","title":"EmbeddedRecord"},{"location":"reference/graphkb/types/#recordlink","text":"RecordLink = Union [ str , Record ]","title":"RecordLink"},{"location":"reference/graphkb/types/#ontologylink","text":"OntologyLink = Union [ str , Ontology ]","title":"OntologyLink"},{"location":"reference/graphkb/types/#position","text":"Position = Union [ BasicPosition , CytobandPosition ]","title":"Position"},{"location":"reference/graphkb/types/#categorybasetermmapping","text":"CategoryBaseTermMapping = List [ Tuple [ str , List [ str ]]]","title":"CategoryBaseTermMapping"},{"location":"reference/graphkb/types/#class-ontology","text":"inherits Record Attributes sourceId ( str ) name ( str ) source ( RecordLink )","title":"class Ontology"},{"location":"reference/graphkb/types/#class-basicposition","text":"inherits EmbeddedRecord Attributes pos ( int )","title":"class BasicPosition"},{"location":"reference/graphkb/types/#class-cytobandposition","text":"inherits EmbeddedRecord Attributes arm ( str ) majorBand ( str ) minorBand ( str )","title":"class CytobandPosition"},{"location":"reference/graphkb/types/#class-variant","text":"inherits Record Attributes reference1 ( OntologyLink ) reference2 (Optional[ OntologyLink ]) type ( OntologyLink ) zygosity ( str ) germline ( bool )","title":"class Variant"},{"location":"reference/graphkb/types/#class-positionalvariant","text":"inherits Variant Attributes break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] )","title":"class PositionalVariant"},{"location":"reference/graphkb/types/#class-parsedvariant","text":"inherits TypedDict Attributes reference1 ( str ) reference2 ( Optional[str] ) type ( str ) zygosity ( str ) germline ( bool ) break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] )","title":"class ParsedVariant"},{"location":"reference/graphkb/types/#class-statement","text":"inherits Record Attributes relevance ( OntologyLink ) subject ( OntologyLink ) conditions (List[ OntologyLink ]) evidence (List[ OntologyLink ]) evidenceLevel (List[ OntologyLink ]) source ( RecordLink ) sourceId ( str )","title":"class Statement"},{"location":"reference/graphkb/util/","text":"graphkb.util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2 logger logger = logging . getLogger ( 'graphkb' ) LOG_LEVELS LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE , class IterableNamespace inherits argparse.Namespace convert_to_rid_list() Given a list of records, return their record IDs def convert_to_rid_list ( records : Iterable [ Record ]) -> List [ str ]: Args records (Iterable[ Record ]) Returns List[str] looks_like_rid() Check if an input string looks like a GraphKB ID def looks_like_rid ( rid : str ) -> bool : Args rid ( str ) Returns bool","title":"graphkb.util"},{"location":"reference/graphkb/util/#graphkbutil","text":"","title":"graphkb.util"},{"location":"reference/graphkb/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"reference/graphkb/util/#logger","text":"logger = logging . getLogger ( 'graphkb' )","title":"logger"},{"location":"reference/graphkb/util/#log_levels","text":"LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE ,","title":"LOG_LEVELS"},{"location":"reference/graphkb/util/#class-iterablenamespace","text":"inherits argparse.Namespace","title":"class IterableNamespace"},{"location":"reference/graphkb/util/#convert_to_rid_list","text":"Given a list of records, return their record IDs def convert_to_rid_list ( records : Iterable [ Record ]) -> List [ str ]: Args records (Iterable[ Record ]) Returns List[str]","title":"convert_to_rid_list()"},{"location":"reference/graphkb/util/#looks_like_rid","text":"Check if an input string looks like a GraphKB ID def looks_like_rid ( rid : str ) -> bool : Args rid ( str ) Returns bool","title":"looks_like_rid()"},{"location":"reference/graphkb/vocab/","text":"graphkb.vocab get_equivalent_terms() Get a list of terms equivalent to the current term up to the root term def get_equivalent_terms ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) base_term_name ( str ): the name to get superclasses of root_exclude_term ( str ): the parent term to exlcude along with all of its parent terms ontology_class ( str ) Returns List[ Ontology ] get_term_tree() Get terms equivalent to the base term by traversing the subclassOf tree and expanding related alias and cross reference edges def get_term_tree ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , include_superclasses : bool = True , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object base_term_name ( str ): the term to use as the base of the subclass tree root_exclude_term ( str ) ontology_class ( str ): the default class to query. Defaults to 'Vocabulary' include_superclasses ( bool ): when True the query will include superclasses of the current term Returns List[ Ontology ]: GraphKB records Note: this must be done in 2 calls to avoid going up and down the tree in a single query (exclude adjacent siblings) get_term_by_name() Retrieve a vocaulary term by name def get_term_by_name ( conn : GraphKBConnection , name : str , ontology_class : str = 'Vocabulary' , ** kwargs ) -> Ontology : Args conn ( GraphKBConnection ): the graphkb connection object name ( str ): the name of the Vocabulary term to retrieve ontology_class ( str ) Returns Ontology : Vocabulary record Raises AssertionError : more than one term or no terms with that name were found AssertionError : if the term was not found or more than 1 match was found (expected to be unique) get_terms_set() Get a set of terms of vocabulary given some base/parent term names. Returns the record IDs for the resulting terms def get_terms_set ( graphkb_conn : GraphKBConnection , base_terms : Iterable [ str ], ignore_cache : bool = False ) -> Set [ str ]: Args graphkb_conn ( GraphKBConnection ) base_terms ( Iterable[str] ) ignore_cache ( bool ) Returns Set[str]","title":"graphkb.vocab"},{"location":"reference/graphkb/vocab/#graphkbvocab","text":"","title":"graphkb.vocab"},{"location":"reference/graphkb/vocab/#get_equivalent_terms","text":"Get a list of terms equivalent to the current term up to the root term def get_equivalent_terms ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) base_term_name ( str ): the name to get superclasses of root_exclude_term ( str ): the parent term to exlcude along with all of its parent terms ontology_class ( str ) Returns List[ Ontology ]","title":"get_equivalent_terms()"},{"location":"reference/graphkb/vocab/#get_term_tree","text":"Get terms equivalent to the base term by traversing the subclassOf tree and expanding related alias and cross reference edges def get_term_tree ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , include_superclasses : bool = True , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object base_term_name ( str ): the term to use as the base of the subclass tree root_exclude_term ( str ) ontology_class ( str ): the default class to query. Defaults to 'Vocabulary' include_superclasses ( bool ): when True the query will include superclasses of the current term Returns List[ Ontology ]: GraphKB records Note: this must be done in 2 calls to avoid going up and down the tree in a single query (exclude adjacent siblings)","title":"get_term_tree()"},{"location":"reference/graphkb/vocab/#get_term_by_name","text":"Retrieve a vocaulary term by name def get_term_by_name ( conn : GraphKBConnection , name : str , ontology_class : str = 'Vocabulary' , ** kwargs ) -> Ontology : Args conn ( GraphKBConnection ): the graphkb connection object name ( str ): the name of the Vocabulary term to retrieve ontology_class ( str ) Returns Ontology : Vocabulary record Raises AssertionError : more than one term or no terms with that name were found AssertionError : if the term was not found or more than 1 match was found (expected to be unique)","title":"get_term_by_name()"},{"location":"reference/graphkb/vocab/#get_terms_set","text":"Get a set of terms of vocabulary given some base/parent term names. Returns the record IDs for the resulting terms def get_terms_set ( graphkb_conn : GraphKBConnection , base_terms : Iterable [ str ], ignore_cache : bool = False ) -> Set [ str ]: Args graphkb_conn ( GraphKBConnection ) base_terms ( Iterable[str] ) ignore_cache ( bool ) Returns Set[str]","title":"get_terms_set()"}]}