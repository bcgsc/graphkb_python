{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GraphKB Python Adapter User Manual The GraphKB python adapter is a python package to facilitate interacting with the GraphKB API. The GraphKB API is a REST API https://graphkb.bcgsc.ca/api) . The openapi specification is hosted here: https://graphkb-api.bcgsc.ca/api/spec . The client also contains documentation on the background and features of GraphKB This adapter adds functions for common queries as well as for paginating and authenticating Getting Started Install the python adapter with pip pip install graphkb This will require python 3.6 or greater. Next, start incorporating graphkb into your own python project/script. The script below gets version information from graphkb from graphkb import GraphKBConnection gkb_conn = GraphKBConnection () # authenticate the current user gkb_conn . login ( 'myusername' , 'mypassword' ) # get the version information version_metadata = gkb_conn . request ( '/version' ) Querying GraphKB uses the /query endpoint which takes the query arguments in the request body. See the openapi specification for more details on how to build this object. Matching Variants There are 2 main matching functions, one of positional variants and one for category variants. Let's take a look at a couple of examples from graphkb import GraphKBConnection from graphkb.match import match_positional_variant gkb_conn = GraphKBConnection () gkb_conn . login ( 'myusername' , 'mypassword' ) variant_matches = match_positional_variant ( gkb_conn , 'KRAS:p.G12D' ) This will give you a list of variants from GraphKB that are considered to match the input. We can then use this list of variants to fetch related annotations from graphkb.util import convert_to_rid_list annotations = gkb_conn . query ({ 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' } }) This will fetch a list of statements where any of the matched variants are conditions for the statement","title":"Home"},{"location":"#graphkb-python-adapter-user-manual","text":"The GraphKB python adapter is a python package to facilitate interacting with the GraphKB API. The GraphKB API is a REST API https://graphkb.bcgsc.ca/api) . The openapi specification is hosted here: https://graphkb-api.bcgsc.ca/api/spec . The client also contains documentation on the background and features of GraphKB This adapter adds functions for common queries as well as for paginating and authenticating","title":"GraphKB Python Adapter User Manual"},{"location":"#getting-started","text":"Install the python adapter with pip pip install graphkb This will require python 3.6 or greater. Next, start incorporating graphkb into your own python project/script. The script below gets version information from graphkb from graphkb import GraphKBConnection gkb_conn = GraphKBConnection () # authenticate the current user gkb_conn . login ( 'myusername' , 'mypassword' ) # get the version information version_metadata = gkb_conn . request ( '/version' ) Querying GraphKB uses the /query endpoint which takes the query arguments in the request body. See the openapi specification for more details on how to build this object.","title":"Getting Started"},{"location":"#matching-variants","text":"There are 2 main matching functions, one of positional variants and one for category variants. Let's take a look at a couple of examples from graphkb import GraphKBConnection from graphkb.match import match_positional_variant gkb_conn = GraphKBConnection () gkb_conn . login ( 'myusername' , 'mypassword' ) variant_matches = match_positional_variant ( gkb_conn , 'KRAS:p.G12D' ) This will give you a list of variants from GraphKB that are considered to match the input. We can then use this list of variants to fetch related annotations from graphkb.util import convert_to_rid_list annotations = gkb_conn . query ({ 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' } }) This will fetch a list of statements where any of the matched variants are conditions for the statement","title":"Matching Variants"},{"location":"reference/graphkb/__init__/","text":"graphkb DEFAULT_URL DEFAULT_URL = 'https://graphkb-api.bcgsc.ca/api' DEFAULT_LIMIT DEFAULT_LIMIT = 1000 class GraphKBConnection GraphKBConnection.request() Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict GraphKBConnection.post() Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict join_url() Join parts of a URL into a full URL def join_url ( base_url : str , * parts ) -> str : Args base_url ( str ) Returns str millis_interval() start and end are datetime instances def millis_interval ( start : datetime , end : datetime ) -> int : Args start ( datetime ) end ( datetime ) Returns int","title":"graphkb"},{"location":"reference/graphkb/__init__/#graphkb","text":"","title":"graphkb"},{"location":"reference/graphkb/__init__/#default_url","text":"DEFAULT_URL = 'https://graphkb-api.bcgsc.ca/api'","title":"DEFAULT_URL"},{"location":"reference/graphkb/__init__/#default_limit","text":"DEFAULT_LIMIT = 1000","title":"DEFAULT_LIMIT"},{"location":"reference/graphkb/__init__/#class-graphkbconnection","text":"","title":"class GraphKBConnection"},{"location":"reference/graphkb/__init__/#graphkbconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"GraphKBConnection.request()"},{"location":"reference/graphkb/__init__/#graphkbconnectionpost","text":"Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict","title":"GraphKBConnection.post()"},{"location":"reference/graphkb/__init__/#join_url","text":"Join parts of a URL into a full URL def join_url ( base_url : str , * parts ) -> str : Args base_url ( str ) Returns str","title":"join_url()"},{"location":"reference/graphkb/__init__/#millis_interval","text":"start and end are datetime instances def millis_interval ( start : datetime , end : datetime ) -> int : Args start ( datetime ) end ( datetime ) Returns int","title":"millis_interval()"},{"location":"reference/graphkb/genes/","text":"graphkb.genes Methods for retrieving gene annotation lists from GraphKB ONCOKB_SOURCE_NAME ONCOKB_SOURCE_NAME = 'oncokb' ONCOGENE ONCOGENE = 'oncogenic' TUMOUR_SUPPRESSIVE TUMOUR_SUPPRESSIVE = 'tumour suppressive' FUSION_NAMES FUSION_NAMES = [ 'structural variant' , 'fusion' ] GENE_RETURN_PROPERTIES GENE_RETURN_PROPERTIES = [ 'name' , '@rid' , '@class' , 'sourceId' , 'sourceIdVersion' , 'source.name' , 'source.@rid' , 'displayName' , 'biotype' , 'deprecated' , ] get_oncokb_oncogenes() Gets the list of oncogenes stored in GraphKB derived from OncoKB def get_oncokb_oncogenes ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records get_oncokb_tumour_supressors() Gets the list of tumour supressor genes stored in GraphKB derived from OncoKB def get_oncokb_tumour_supressors ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records get_genes_from_variant_types() Retrieve a list of Genes which are found in variants on the given types def get_genes_from_variant_types ( conn : GraphKBConnection , types : List [ str ], source_record_ids : List [ str ] = [] ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object types ( List[str] ): list of names of variant types source_record_ids ( List[str] ): list of sources ids to filter genes by Returns List[ Ontology ]: gene (Feature) records","title":"graphkb.genes"},{"location":"reference/graphkb/genes/#graphkbgenes","text":"Methods for retrieving gene annotation lists from GraphKB","title":"graphkb.genes"},{"location":"reference/graphkb/genes/#oncokb_source_name","text":"ONCOKB_SOURCE_NAME = 'oncokb'","title":"ONCOKB_SOURCE_NAME"},{"location":"reference/graphkb/genes/#oncogene","text":"ONCOGENE = 'oncogenic'","title":"ONCOGENE"},{"location":"reference/graphkb/genes/#tumour_suppressive","text":"TUMOUR_SUPPRESSIVE = 'tumour suppressive'","title":"TUMOUR_SUPPRESSIVE"},{"location":"reference/graphkb/genes/#fusion_names","text":"FUSION_NAMES = [ 'structural variant' , 'fusion' ]","title":"FUSION_NAMES"},{"location":"reference/graphkb/genes/#gene_return_properties","text":"GENE_RETURN_PROPERTIES = [ 'name' , '@rid' , '@class' , 'sourceId' , 'sourceIdVersion' , 'source.name' , 'source.@rid' , 'displayName' , 'biotype' , 'deprecated' , ]","title":"GENE_RETURN_PROPERTIES"},{"location":"reference/graphkb/genes/#get_oncokb_oncogenes","text":"Gets the list of oncogenes stored in GraphKB derived from OncoKB def get_oncokb_oncogenes ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records","title":"get_oncokb_oncogenes()"},{"location":"reference/graphkb/genes/#get_oncokb_tumour_supressors","text":"Gets the list of tumour supressor genes stored in GraphKB derived from OncoKB def get_oncokb_tumour_supressors ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records","title":"get_oncokb_tumour_supressors()"},{"location":"reference/graphkb/genes/#get_genes_from_variant_types","text":"Retrieve a list of Genes which are found in variants on the given types def get_genes_from_variant_types ( conn : GraphKBConnection , types : List [ str ], source_record_ids : List [ str ] = [] ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object types ( List[str] ): list of names of variant types source_record_ids ( List[str] ): list of sources ids to filter genes by Returns List[ Ontology ]: gene (Feature) records","title":"get_genes_from_variant_types()"},{"location":"reference/graphkb/match/","text":"graphkb.match Functions which return Variants from GraphKB which match some input variant definition INPUT_COPY_CATEGORIES INPUT_COPY_CATEGORIES = IterableNamespace ( AMP = 'amplification' , ANY_GAIN = 'copy gain' , ANY_LOSS = 'copy loss' , DEEP = 'deep deletion' , GAIN = 'low level copy gain' , LOSS = 'shallow deletion' , ) INPUT_EXPRESSION_CATEGORIES INPUT_EXPRESSION_CATEGORIES = IterableNamespace ( UP = 'increased expression' , DOWN = 'reduced expression' ) AMBIGUOUS_AA AMBIGUOUS_AA = [ 'x' , '?' , 'X' ] VARIANT_RETURN_PROPERTIES VARIANT_RETURN_PROPERTIES = ( BASE_RETURN_PROPERTIES + [ f 'type. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'reference1. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ f 'reference2. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ 'zygosity' , 'germline' , 'displayName' ] POS_VARIANT_RETURN_PROPERTIES POS_VARIANT_RETURN_PROPERTIES = VARIANT_RETURN_PROPERTIES + [ 'break1Start' , 'break1End' , 'break2Start' , 'break2End' , 'break1Repr' , 'break2Repr' , 'refSeq' , 'untemplatedSeq' , 'untemplatedSeqSize' , 'truncation' , 'assembly' , GENE_NAME_CACHE GENE_NAME_CACHE : Set [ str ] = set () match_category_variant() Returns a list of variants matching the input variant def match_category_variant ( conn : GraphKBConnection , gene_name : str , category : str , root_exclude_term : str = '' , gene_is_record_id : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) root_exclude_term ( str ) gene_is_record_id ( bool ): the gene_name is a record ID to be expanded not a feature name Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises FeatureNotFoundError : The gene could not be found in GraphKB match_copy_variant() Returns a list of variants matching the input variant def match_copy_variant ( conn : GraphKBConnection , gene_name : str , category : str , drop_homozygous : bool = False ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) drop_homozygous ( bool ): Drop homozygous matches from the result when true Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises ValueError : The input copy category is not recognized positions_overlap() Check if 2 Position records from GraphKB indicate an overlap def positions_overlap ( pos_record : BasicPosition , range_start : BasicPosition , range_end : Optional [ BasicPosition ] = None ) -> bool : Args pos_record ( BasicPosition ): the record to compare range_start ( BasicPosition ): the position record indicating the start of an uncertainty range range_end (Optional[ BasicPosition ]): the position record indicating the end of an uncertainty range Returns bool : True if the positions overlap Raises NotImplementedError : if a cytoband type position is given compare_positional_variants() Compare 2 variant records from GraphKB to determine if they are equivalent def compare_positional_variants ( variant : Union [ PositionalVariant , ParsedVariant ], reference_variant : Union [ PositionalVariant , ParsedVariant ], ) -> bool : Args variant (Union[ PositionalVariant , ParsedVariant ]): the input variant reference_variant (Union[ PositionalVariant , ParsedVariant ]): the reference (matched) variant record Returns bool : True if the records are equivalent match_positional_variant() Given the HGVS+ representation of some positional variant, parse it and match it to annotations in GraphKB def match_positional_variant ( conn : GraphKBConnection , variant_string : str ) -> List [ Variant ]: Args conn ( GraphKBConnection ) variant_string ( str ): the HGVS+ annotation string Returns List[ Variant ]: A list of matched statement records Raises NotImplementedError : thrown for uncertain position input (ranges) FeatureNotFoundError : One of the genes does not exist in GraphKB","title":"graphkb.match"},{"location":"reference/graphkb/match/#graphkbmatch","text":"Functions which return Variants from GraphKB which match some input variant definition","title":"graphkb.match"},{"location":"reference/graphkb/match/#input_copy_categories","text":"INPUT_COPY_CATEGORIES = IterableNamespace ( AMP = 'amplification' , ANY_GAIN = 'copy gain' , ANY_LOSS = 'copy loss' , DEEP = 'deep deletion' , GAIN = 'low level copy gain' , LOSS = 'shallow deletion' , )","title":"INPUT_COPY_CATEGORIES"},{"location":"reference/graphkb/match/#input_expression_categories","text":"INPUT_EXPRESSION_CATEGORIES = IterableNamespace ( UP = 'increased expression' , DOWN = 'reduced expression' )","title":"INPUT_EXPRESSION_CATEGORIES"},{"location":"reference/graphkb/match/#ambiguous_aa","text":"AMBIGUOUS_AA = [ 'x' , '?' , 'X' ]","title":"AMBIGUOUS_AA"},{"location":"reference/graphkb/match/#variant_return_properties","text":"VARIANT_RETURN_PROPERTIES = ( BASE_RETURN_PROPERTIES + [ f 'type. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'reference1. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ f 'reference2. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ 'zygosity' , 'germline' , 'displayName' ]","title":"VARIANT_RETURN_PROPERTIES"},{"location":"reference/graphkb/match/#pos_variant_return_properties","text":"POS_VARIANT_RETURN_PROPERTIES = VARIANT_RETURN_PROPERTIES + [ 'break1Start' , 'break1End' , 'break2Start' , 'break2End' , 'break1Repr' , 'break2Repr' , 'refSeq' , 'untemplatedSeq' , 'untemplatedSeqSize' , 'truncation' , 'assembly' ,","title":"POS_VARIANT_RETURN_PROPERTIES"},{"location":"reference/graphkb/match/#gene_name_cache","text":"GENE_NAME_CACHE : Set [ str ] = set ()","title":"GENE_NAME_CACHE"},{"location":"reference/graphkb/match/#match_category_variant","text":"Returns a list of variants matching the input variant def match_category_variant ( conn : GraphKBConnection , gene_name : str , category : str , root_exclude_term : str = '' , gene_is_record_id : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) root_exclude_term ( str ) gene_is_record_id ( bool ): the gene_name is a record ID to be expanded not a feature name Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises FeatureNotFoundError : The gene could not be found in GraphKB","title":"match_category_variant()"},{"location":"reference/graphkb/match/#match_copy_variant","text":"Returns a list of variants matching the input variant def match_copy_variant ( conn : GraphKBConnection , gene_name : str , category : str , drop_homozygous : bool = False ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) drop_homozygous ( bool ): Drop homozygous matches from the result when true Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises ValueError : The input copy category is not recognized","title":"match_copy_variant()"},{"location":"reference/graphkb/match/#positions_overlap","text":"Check if 2 Position records from GraphKB indicate an overlap def positions_overlap ( pos_record : BasicPosition , range_start : BasicPosition , range_end : Optional [ BasicPosition ] = None ) -> bool : Args pos_record ( BasicPosition ): the record to compare range_start ( BasicPosition ): the position record indicating the start of an uncertainty range range_end (Optional[ BasicPosition ]): the position record indicating the end of an uncertainty range Returns bool : True if the positions overlap Raises NotImplementedError : if a cytoband type position is given","title":"positions_overlap()"},{"location":"reference/graphkb/match/#compare_positional_variants","text":"Compare 2 variant records from GraphKB to determine if they are equivalent def compare_positional_variants ( variant : Union [ PositionalVariant , ParsedVariant ], reference_variant : Union [ PositionalVariant , ParsedVariant ], ) -> bool : Args variant (Union[ PositionalVariant , ParsedVariant ]): the input variant reference_variant (Union[ PositionalVariant , ParsedVariant ]): the reference (matched) variant record Returns bool : True if the records are equivalent","title":"compare_positional_variants()"},{"location":"reference/graphkb/match/#match_positional_variant","text":"Given the HGVS+ representation of some positional variant, parse it and match it to annotations in GraphKB def match_positional_variant ( conn : GraphKBConnection , variant_string : str ) -> List [ Variant ]: Args conn ( GraphKBConnection ) variant_string ( str ): the HGVS+ annotation string Returns List[ Variant ]: A list of matched statement records Raises NotImplementedError : thrown for uncertain position input (ranges) FeatureNotFoundError : One of the genes does not exist in GraphKB","title":"match_positional_variant()"},{"location":"reference/graphkb/types/","text":"graphkb.types Type annotations used for static type checking in this module Record Record : TypedDict = TypedDict ( 'Record' , { '@rid' : str , '@class' : str }) Attributes @rid ( str ) @class ( str ) EmbeddedRecord EmbeddedRecord : TypedDict = TypedDict ( 'EmbeddedRecord' , { '@class' : str }) Attributes @class ( str ) RecordLink RecordLink = Union [ str , Record ] OntologyLink OntologyLink = Union [ str , Ontology ] Position Position = Union [ BasicPosition , CytobandPosition ] class Ontology inherits Record Attributes sourceId ( str ) name ( str ) source ( RecordLink ) class BasicPosition inherits EmbeddedRecord Attributes pos ( int ) class CytobandPosition inherits EmbeddedRecord Attributes arm ( str ) majorBand ( str ) minorBand ( str ) class Variant inherits Record Attributes reference1 ( OntologyLink ) reference2 (Optional[ OntologyLink ]) type ( OntologyLink ) zygosity ( str ) germline ( bool ) class PositionalVariant inherits Variant Attributes break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] ) class ParsedVariant inherits TypedDict Attributes reference1 ( str ) reference2 ( Optional[str] ) type ( str ) zygosity ( str ) germline ( bool ) break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] ) class Statement inherits Record Attributes relevance ( OntologyLink ) subject ( OntologyLink ) conditions (List[ OntologyLink ]) evidence (List[ OntologyLink ]) evidenceLevel (List[ OntologyLink ]) source ( RecordLink ) sourceId ( str )","title":"graphkb.types"},{"location":"reference/graphkb/types/#graphkbtypes","text":"Type annotations used for static type checking in this module","title":"graphkb.types"},{"location":"reference/graphkb/types/#record","text":"Record : TypedDict = TypedDict ( 'Record' , { '@rid' : str , '@class' : str }) Attributes @rid ( str ) @class ( str )","title":"Record"},{"location":"reference/graphkb/types/#embeddedrecord","text":"EmbeddedRecord : TypedDict = TypedDict ( 'EmbeddedRecord' , { '@class' : str }) Attributes @class ( str )","title":"EmbeddedRecord"},{"location":"reference/graphkb/types/#recordlink","text":"RecordLink = Union [ str , Record ]","title":"RecordLink"},{"location":"reference/graphkb/types/#ontologylink","text":"OntologyLink = Union [ str , Ontology ]","title":"OntologyLink"},{"location":"reference/graphkb/types/#position","text":"Position = Union [ BasicPosition , CytobandPosition ]","title":"Position"},{"location":"reference/graphkb/types/#class-ontology","text":"inherits Record Attributes sourceId ( str ) name ( str ) source ( RecordLink )","title":"class Ontology"},{"location":"reference/graphkb/types/#class-basicposition","text":"inherits EmbeddedRecord Attributes pos ( int )","title":"class BasicPosition"},{"location":"reference/graphkb/types/#class-cytobandposition","text":"inherits EmbeddedRecord Attributes arm ( str ) majorBand ( str ) minorBand ( str )","title":"class CytobandPosition"},{"location":"reference/graphkb/types/#class-variant","text":"inherits Record Attributes reference1 ( OntologyLink ) reference2 (Optional[ OntologyLink ]) type ( OntologyLink ) zygosity ( str ) germline ( bool )","title":"class Variant"},{"location":"reference/graphkb/types/#class-positionalvariant","text":"inherits Variant Attributes break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] )","title":"class PositionalVariant"},{"location":"reference/graphkb/types/#class-parsedvariant","text":"inherits TypedDict Attributes reference1 ( str ) reference2 ( Optional[str] ) type ( str ) zygosity ( str ) germline ( bool ) break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] )","title":"class ParsedVariant"},{"location":"reference/graphkb/types/#class-statement","text":"inherits Record Attributes relevance ( OntologyLink ) subject ( OntologyLink ) conditions (List[ OntologyLink ]) evidence (List[ OntologyLink ]) evidenceLevel (List[ OntologyLink ]) source ( RecordLink ) sourceId ( str )","title":"class Statement"},{"location":"reference/graphkb/util/","text":"graphkb.util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2 logger logger = logging . getLogger ( 'graphkb' ) LOG_LEVELS LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE , class IterableNamespace inherits argparse.Namespace convert_to_rid_list() Given a list of records, return their record IDs def convert_to_rid_list ( records : Iterable [ Record ]) -> List [ str ]: Args records (Iterable[ Record ]) Returns List[str]","title":"graphkb.util"},{"location":"reference/graphkb/util/#graphkbutil","text":"","title":"graphkb.util"},{"location":"reference/graphkb/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"reference/graphkb/util/#logger","text":"logger = logging . getLogger ( 'graphkb' )","title":"logger"},{"location":"reference/graphkb/util/#log_levels","text":"LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE ,","title":"LOG_LEVELS"},{"location":"reference/graphkb/util/#class-iterablenamespace","text":"inherits argparse.Namespace","title":"class IterableNamespace"},{"location":"reference/graphkb/util/#convert_to_rid_list","text":"Given a list of records, return their record IDs def convert_to_rid_list ( records : Iterable [ Record ]) -> List [ str ]: Args records (Iterable[ Record ]) Returns List[str]","title":"convert_to_rid_list()"},{"location":"reference/graphkb/vocab/","text":"graphkb.vocab get_equivalent_terms() Get a list of terms equivalent to the current term up to the root term def get_equivalent_terms ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) base_term_name ( str ): the name to get superclasses of root_exclude_term ( str ): the parent term to exlcude along with all of its parent terms ontology_class ( str ) Returns List[ Ontology ] get_term_tree() Get terms equivalent to the base term by traversing the subclassOf tree and expanding related alias and cross reference edges def get_term_tree ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , include_superclasses : bool = True , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object base_term_name ( str ): the term to use as the base of the subclass tree root_exclude_term ( str ) ontology_class ( str ): the default class to query. Defaults to 'Vocabulary' include_superclasses ( bool ): when True the query will include superclasses of the current term Returns List[ Ontology ]: GraphKB records get_term_by_name() Retrieve a vocaulary term by name def get_term_by_name ( conn : GraphKBConnection , name : str , ontology_class : str = 'Vocabulary' , ** kwargs ) -> Ontology : Args conn ( GraphKBConnection ): the graphkb connection object name ( str ): the name of the Vocabulary term to retrieve ontology_class ( str ) Returns Ontology : Vocabulary record Raises AssertionError : more than one term or no terms with that name were found AssertionError : if the term was not found or more than 1 match was found (expected to be unique)","title":"graphkb.vocab"},{"location":"reference/graphkb/vocab/#graphkbvocab","text":"","title":"graphkb.vocab"},{"location":"reference/graphkb/vocab/#get_equivalent_terms","text":"Get a list of terms equivalent to the current term up to the root term def get_equivalent_terms ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) base_term_name ( str ): the name to get superclasses of root_exclude_term ( str ): the parent term to exlcude along with all of its parent terms ontology_class ( str ) Returns List[ Ontology ]","title":"get_equivalent_terms()"},{"location":"reference/graphkb/vocab/#get_term_tree","text":"Get terms equivalent to the base term by traversing the subclassOf tree and expanding related alias and cross reference edges def get_term_tree ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , include_superclasses : bool = True , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object base_term_name ( str ): the term to use as the base of the subclass tree root_exclude_term ( str ) ontology_class ( str ): the default class to query. Defaults to 'Vocabulary' include_superclasses ( bool ): when True the query will include superclasses of the current term Returns List[ Ontology ]: GraphKB records","title":"get_term_tree()"},{"location":"reference/graphkb/vocab/#get_term_by_name","text":"Retrieve a vocaulary term by name def get_term_by_name ( conn : GraphKBConnection , name : str , ontology_class : str = 'Vocabulary' , ** kwargs ) -> Ontology : Args conn ( GraphKBConnection ): the graphkb connection object name ( str ): the name of the Vocabulary term to retrieve ontology_class ( str ) Returns Ontology : Vocabulary record Raises AssertionError : more than one term or no terms with that name were found AssertionError : if the term was not found or more than 1 match was found (expected to be unique)","title":"get_term_by_name()"}]}